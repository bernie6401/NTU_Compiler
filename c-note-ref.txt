fgetc(): https://www.1ju.org/cprogramming/fputc-fgetc-in-c
isdigit(): http://tw.gitbook.net/c_standard_library/c_function_isdigit.html
ungetc(): http://tw.gitbook.net/c_standard_library/c_function_ungetc.html
islower(): https://pydoing.blogspot.com/2010/07/c-islower.html
#ifndef: it's an abbreviation of "if not define" https://www.1ju.org/cprogramming/c-preprocessor-ifndef
atoi(): http://tw.gitbook.net/c_standard_library/c_function_atoi.html



CT project:
	objective:
	1. 要能夠辨識多個char所組合的變數，原本的變數都只有一個char，現在是不限字元，挑戰在於會跟原本的保流字混合，例如floating的f、integer的i和print的p等等，此時可以考慮用空白字元當作辨識的依據
		Revise scanner function
	2.做optimization->constant folding，目的是把一些簡單的加減運算能夠直接在compiler的call generation或parsing的時候處理掉，而不是在放到run time的時候才執行，可以在parse的時候辨識並直接運算完成
		Revise *parseExpression function and InitializeTable and add_table and buld function


這樣一整串的就是
assignment statement
v = zzz - r / ccccc

statement就是像print
這樣或是單純附值

expression就是動用+-*/
的operator



// Expression *parseExpression( FILE *source, Expression *lvalue ) //need change
// {
//     Token token = scanner(source);  //token == '+'
//     Expression *expr;

//     int len_identifier = 0;

//     switch(token.type)
//     {
//         case PlusOp:
//             expr = (Expression *)malloc( sizeof(Expression) );
//             (expr->v).type = PlusNode;
//             (expr->v).val.op = Plus;
//             expr->leftOperand = lvalue;
//             expr->rightOperand = parseValue(source);
//             return parseExpressionTail(source, expr);
//         case MinusOp:
//             expr = (Expression *)malloc( sizeof(Expression) );
//             (expr->v).type = MinusNode;
//             (expr->v).val.op = Minus;
//             expr->leftOperand = lvalue;
//             expr->rightOperand = parseValue(source);
//             return parseExpressionTail(source, expr);
//         /*-----------------------Homework------------------------*/
//         case MulOp:
//             expr = (Expression *)malloc( sizeof(Expression) );
//             (expr->v).type = MulNode;
//             (expr->v).val.op = Mul;
//             expr->leftOperand = lvalue;
//             expr->rightOperand = parseValue(source);
//             return parseExpressionTail(source, expr);
//         case DivOp:
//             expr = (Expression *)malloc( sizeof(Expression) );
//             (expr->v).type = DivNode;
//             (expr->v).val.op = Div;
//             expr->leftOperand = lvalue;
//             expr->rightOperand = parseValue(source);
//             return parseExpressionTail(source, expr);
//         /*-----------------------Homework------------------------*/
//         case Alphabet:
//         case PrintOp:
//             /*-----------------------Homework------------------------*/
//             unget_token(source, token);
//             /*-----------------------Homework------------------------*/
//             // ungetc(token.tok[0], source);
//             return NULL;
//         case EOFsymbol:
//             return NULL;
//         default:
//             printf("Syntax Error: Expect a numeric value or an identifier %s\n", token.tok);
//             exit(1);
//     }
// }
